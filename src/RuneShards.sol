// SPDX-License-Identifier: UNLICENSED

/*
                                  ,▄▄▄██████████████▄▄▄,
                           ,▄██████▀▀▀╙╙╙││└└││╙╙╙▀▀▀██████▄,
                       ,▄█████╩╙└│░░░░░░░░░░░░░░░░░░░░░░│╙▀▀███▄╓
                    ▄████▀╬╜││░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░└╙▀███▄
                 ,████╠╬╩│░░░░░░░░░░▄▄;░░░░▄▄µ░░░░▄▄░░░░░░░░░░░░░╙▀███µ
               ╓███╬░╩╙░░░░░░░░░░░░░██▌░░░░██▌░░░░██▒░░░░░░░░░░░░░░░╙▀██▄
             ╓███▒╬╩│░░░░░░▄██'░░░░░██▒▄▄▄▄██▌▄▄▄▄██▒░░░░░▄█▄░░░░░░░░░│▀██▄
            ███▒╬╣░╓██████▄│╙███µ░░░╙██████████████▀░░░░▄██▀└░░░░░░░░░░░│▀██,
          ╓██▒╬╬╩│░██▌.░╟██░░▄██▌░░░░░░░░▐████▌░░░░░░░░▐██▄░░░░╓█▄░░░░░░░░╙██▌
         ▄██░╬╬│░░░╚███████▄███└░░░░░░░░░▐████▌░░░░░░░░,│▀███▄███▀░░░░░░░░░.╚██
        ███╬╬╬│░░░╓▄│╙▀▀▀████▒░,,░░░░░░░░╚████▌░░░░░░░░██∩'████▒░░░░¡▄░░░░░░░╙██
       ███╬╬╣░░░░╙███▄,███▀▀██████▀░░░░░░░░██▌░░░░░░░░░█████▀╙███▄,███▀░░░░░░░╙██
      ▐██╬╬╠░░░░░░░╙████▀¡░▐█████▄░░░░░░░░░██▌░░░\▄███████████▄╙████▀¡░░░░░░░░░╚██
      ██▒╬╬▒░░░░░░░░░░░░░░░¡██░╙███▄░░░░░░░██▌░░░░│▀╠████▌╙╙▀╙└░░░░░░░░░░░░░░░░░██▄
     ╫█▌╬╬╬░░░▄▄▄▄▄▄░░░░░░░░~│░░░╙▀██▄│░░░░██▌░░░░▄███▀██▌░░░░░░░░░░▄▄▄▄▄▄░░░░░░"██
     ██▒╬╬▒░░░╚▀▀▀███░░░░░░░░░░░░░░│▀███░,▄███▄░▄███└░│╙▀.░░░░░░░░░███▀▀▀▀░░░░░░░██─
    ▐██╠╬╠░░░░███████▒░░░░░░░░░░░░░░░.▀████▀▀█████└░░░░░j██'╔▄▄░▄█▌██▌░░░░░░░░░░░▐█▌
    ▐█▌╠╬╬░░░░╠╠╠╠╟██▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄███,░░░░^╟██▄▄▄▄▄▄▄█████████▒██▌▄▄▄▄░░░░░░░▐█▌
    ▐█▌╬╬╬░░░░╫█████████████████████████▌░░░░░░j██████████████████████████░░░░░░░j█▌
    ▐█▌╠╬╠░░░░███████▒░░░░░░░░░░░░░░░░╙██▄,░░,▄██▌░░░░░░j███╟██╚██▌██▌░░░░░░░░░░░▐█▌
     ██╠╬╠▒░░░╙▀▀▀▀██░░░░░░░░░░░░░░░░▄█████████▀███ƒ░░░░"╙└░│││░│╙▀██▌░░░░░░░░░░░╟█⌐
     ██▒╬╬▒░░░╫█████▀░░░░░░░░░,░░░,▄██▀│░░░██▌░░│▀███▄░░░░░░░░░░░░░╙██████░░░░░░░██
     ╘██╬╬╬░░░░░░░░░░░░░░░░░░▐██,███▀^░░░░░██▌░░░░░╙███▄░░░░░░░░░░░░░░░░░░░░░░░░▐█▌
      ╟█▒╬╬▒░░░░░░░░,▄▄▄░░░▄▄╟████▀'░░░░░░░██▌░░░░░░░╙█████▄░░░░;▄▄▄░░░░░░░░░░░.██
       ██▒╬╬▒░░░░░▄██████▄╙█████████▀░░░░░░██▌░░░░░░░░X██████▄▄██████▄░░░░░  ,░██¬
        ██▒╬╬▒░░░╙██╙│░╙▀███████w░░░░░░░░░░██▌░░░░░░░░░│╙███████▀│░╙▀█▀░░Σ"²φ░██⌐
         ██▒╠╬▒░░░░░░░#███████└│░░░░░░░░░░░██▌░░░░░░░░░░░│▄█████▄░░░░│░░░≥ «░██─
          ▀██╠╬▒░░░░░░Φ████╕▀███;░░░░░░░░░░██▌░░░░░░░░░░▄██▀└│╙███░░░░Σ   ░╓██
           ╙██▒╬▓▒░░░░░│┌╙.░░▄██▌░░░░,▄▄▄▄▄██▌▄▄▄▄░░░░░▐██▄░░░░░│░░░δ   «░██▀
             ╙██▒╬▒░░░░░░░░▄███└░░░░████████████████░░░░│▀███░░░░░Σ   ,░▄█▀`
               ▀██▒╬▒░░░░░░░╙└░░░░░░██▌▐█████████░██▒░░░░░.╙.░░≥"   «░▄█▀`
                 ╙███╠▒Q░░░░░░░░░░░░██▌╟██;██▌╟██░██▒░░░░░░░²^   ╓φ▄██▀'
                   └▀██▄╬╗▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░   ,≡░▄██▀└
                      └╙████≥▄░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▄▄██▀└
                          └╙▀████▄▄░░░░░░░░░░░░░░░░░░│▄▄▄██▀▀└
                               '╙╙▀▀████████████████▀▀▀╙─ 
*/

pragma solidity =0.8.4;

import "openzeppelin-contracts-v0.8/token/ERC20/ERC20.sol";
import "openzeppelin-contracts-v0.8/token/ERC20/extensions/draft-ERC20Permit.sol";
import "openzeppelin-contracts-v0.8/token/ERC20/extensions/ERC20Votes.sol";
import "openzeppelin-contracts-v0.8/security/Pausable.sol";
import "openzeppelin-contracts-v0.8/access/AccessControl.sol";
import "openzeppelin-contracts-v0.8/utils/structs/EnumerableSet.sol";

/**
* @notice Rune Shards (RXS) is the governance token for the Rune ecosystem.
*/
contract RuneShards is
    ERC20,
    ERC20Permit,
    ERC20Votes,
    AccessControl
{
    using EnumerableSet for EnumerableSet.AddressSet;


    /* SECTION: Public constants. */

    ///@notice Identifier for the role able to perform dev functions.
    bytes32 public constant DEV_ROLE = keccak256("DEV_ROLE");

    ///@notice Standard figure for basis points.
    uint256 public constant BASIS = 10000;


    /* SECTION: Public fields. */

    ///@notice Basis points for the vault fee.
    uint256 public vaultFeeBasis = 80;
    ///@notice Basis points for the charity fee.
    uint256 public charityFeeBasis = 10;
    ///@notice Basis points for the dev fee.
    uint256 public devFeeBasis = 10;
    ///@notice Basis points for the bot fee.
    uint256 public botFeeBasis = 10000;

    ///@notice Vault fee address.
    address public vaultAddress =
        address(0x602a27bBf954b6945534a84C8c88FB8cA9E92B7F);
    ///@notice Charity fee address.
    address public charityAddress =
        address(0xA40b29b0DACb37331456c2ca3b65E56a6D79FC9E);
    ///@notice Dev fee address.
    address public devAddress =
        address(0xEc9e6FBb58b3633B132dA9afB94A43446845edC8);
    ///@notice Bot fee address.
    address public botAddress =
        address(0x602a27bBf954b6945534a84C8c88FB8cA9E92B7F);


    /* SECTION: Private constants. */

    ///@notice The address to send burnt tokens to.
    address private constant BURN_ADDRESS = address(0xdEaD);

    ///@notice The chain id for the Binance Smart Chain.
    uint256 private constant BSC_CHAIN_ID = 56;

    ///@notice The chain id for hardhat tests.
    uint256 private constant HARDHAT_CHAIN_ID = 31337;

    /* SECTION: Private fields. */

    /// @notice The RUNE token to be swapped
    IERC20 private rune = IERC20(0xA9776B590bfc2f956711b3419910A5Ec1F63153E);

    ///@notice Set of addresses that are excluded from fees. */
    EnumerableSet.AddressSet private excluded;
    ///@notice Set of addresses identified as bots, subject to bot fees. */
    EnumerableSet.AddressSet private bot;


    /* SECTION: Events. */

    ///@notice Emitted when a user swaps RUNE to RXS.
    event Swap(address indexed swapper, uint256 amount);
    ///@notice Emitted when a non-RXS token mistakenly sent to the contract is rescued.
    event RescueTokens(
        IERC20 indexed token,
        address indexed recipient,
        uint256 amount
    );


    /* SECTION: Constructor. */

    /**
     * @notice Setup Rune Shards.
     *
     * @dev This contract is designed to be used cross-chain.
     *
     * The home chain is the Binance Smart Chain. When deploying to BSC, the total supply
     * will be minted to this contract, to allow Rune to be swapped for RXS at a 1:10000 ratio.
     *
     * When deploying on other chains, the constructor parameter `mintTo` will be the recipient
     * of the total supply mint. This is to allow custodial contracts to act as cross-chain bridges.
     *
     * If `mintTo` is 0, the supply will be minted to the contract (as though deployed on BSC). This
     * is to allow testing of how the contract will behave on BSC using automated test frameworks.
     *
     * @param mintTo The address to receive the minted supply if not deploying on BSC.
     *  If 0, the minted supply will be sent to the contract for testing purposes.
     */
    constructor(address mintTo)
        ERC20("Rune Shards", "RXS")
        ERC20Permit("Rune Shards")
    {
        // Deployer gets admin role.
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);

        // Add this contract to excluded so there are no fees on swap.
        excluded.add(address(this));

        /*
            Swap rate RUNE -> RXS is 1:10000.

            This figure is the total supply of RUNE minus balance of
            the burn address * 10000.

            (192,999,312.886826396393950000)

            This is the only place in the contract that _mint is
            called, and so this is the maximum amount of RXS that can
            ever exist.
        */
        if (BSC_CHAIN_ID == block.chainid || address(0) == mintTo) {
            mintTo = address(this);
        }
        super._mint(mintTo, 192999312886826396393950000);
    }


    /* SECTION: Unrestricted functions. */

    /**
     * @notice Swap RUNE for RXS at a ratio of 1:10000.
     *
     * This is a one-way trip: RUNE is sent to the burn address.
     *
     * Emits a {Swap} event for transparency.
     *
     * @param amount Amount of RUNE to swap.
     */
    function swap(uint256 amount) external {
        // Only allow swapping on home chain (BSC) or when testing.
        require(
            BSC_CHAIN_ID == block.chainid || HARDHAT_CHAIN_ID == block.chainid
        );

        uint256 balance = rune.balanceOf(BURN_ADDRESS);

        rune.transferFrom(_msgSender(), BURN_ADDRESS, amount);

        uint256 newBalance = rune.balanceOf(BURN_ADDRESS) - balance;
        uint256 swapAmount = newBalance * 10000;

        _approve(address(this), _msgSender(), swapAmount);
        transferFrom(address(this), _msgSender(), swapAmount);

        emit Swap(_msgSender(), swapAmount);
    }


    /* SECTION: View/pure functions. */

    /**
     * @notice Retrieve the set of bot addresses.
     * @return The set of bot addresses.
     */
    function botAll() external view returns (address[] memory) {
        return bot.values();
    }

    /**
     * @notice Retrieve a specific bot address.
     *
     * @param index The index of the bot address to retrieve.
     * @return The bot address at the specified index.
     */
    function botAt(uint256 index) external view returns (address) {
        return bot.at(index);
    }

    /**
     * @notice Retrieve the number of bot addresses.
     * @return The number of bot addresses.
     */
    function botLength() external view returns (uint256) {
        return bot.length();
    }

    /**
     * @notice Retrieve the set of addresses excluded from fees.
     * @return The set of addresses excluded from fees.
     */
    function excludedAll() external view returns (address[] memory) {
        return excluded.values();
    }

    /**
     * @notice Retrieve a specific address excluded from fees.
     *
     * @param index The index of the address excluded from fees to retrieve.
     * @return The address excluded from fees at the specified index.
     */
    function excludedAt(uint256 index) external view returns (address) {
        return excluded.at(index);
    }

    /**
     * @notice Retrieve the number of addresses excluded from fees.
     * @return The number of addresses excluded from fees.
     */
    function excludedLength() external view returns (uint256) {
        return excluded.length();
    }

    /**
     * @notice Determine wheter a specified address is a bot.
     *
     * @param _bot The address of the potential bot.
     * @return Whether the address is a bot.
     */
    function isBot(address _bot) external view returns (bool) {
        return bot.contains(_bot);
    }

    /**
     * @notice Determine wheter a specified address is excluded from fees.
     *
     * @param _excluded The address of the potential excluded address.
     * @return Whether the address is excluded.
     */
    function isExcluded(address _excluded) external view returns (bool) {
        return excluded.contains(_excluded);
    }


    /* SECTION: Privileged functions. */

    /**
     * @notice Add an address to the set of addresses subject to bot fees.
     *
     * @param _bot The address to add.
     */
    function addBot(address _bot) external onlyRole(DEV_ROLE) {
        // Don't allow this contract to be added as a bot.
        require(_bot != address(this), "Can't add Rune Shards to bots");

        bot.add(_bot);
    }

    /**
     * @notice Add an address to the set of addresses exempted from fees.
     *
     * @param _excluded The address to exclude.
     */
    function addExcluded(address _excluded) external onlyRole(DEV_ROLE) {
        excluded.add(_excluded);
    }

    /**
     * @notice Remove an address from the set of addresses subject to bot fees.
     *
     * @param _bot The address to remove.
     */
    function removeBot(address _bot) external onlyRole(DEV_ROLE) {
        bot.remove(_bot);
    }

    /**
     * @notice Remove an address from the set of addresses exempted from fees.
     *
     * @param _reincluded The address to reinclude.
     */
    function removeExcluded(address _reincluded) external onlyRole(DEV_ROLE) {
        // Don't allow this contract to be reincluded, so there are no fees on swap.
        require(
            _reincluded != address(this),
            "Can't remove Rune Shards from exclusions"
        );

        excluded.remove(_reincluded);
    }

    /**
     * @notice Send tokens mistakenly transferred to this contract to the dev address.
     *
     * These can subsequently be sent to the user who sent them here.
     *
     * Emits a {RescueTokens} event for transparency.
     *
     * @dev Does not allow the rescue of RXS for obvious reasons!
     * @param token Address of the token to rescue.
     */
    function rescueTokens(IERC20 token) external onlyRole(DEV_ROLE) {
        require(address(token) != address(this));

        uint256 balance = token.balanceOf(address(this));
        token.transfer(_msgSender(), balance);

        emit RescueTokens(token, _msgSender(), balance);
    }

    /**
     * @notice Set fee addresses and basis rates.
     *
     * @dev Fee addresses cannot be the zero address.
     *
     * Fee basis rates are constrained.
     *
     * @param _vaultAddress Vault address.
     * @param _charityAddress Charity address.
     * @param _devAddress Dev address.
     * @param _botAddress Bot address.
     * @param _vaultFeeBasis Vault fee basis.
     * @param _charityFeeBasis Charity fee basis.
     * @param _devFeeBasis Dev fee basis.
     * @param _botFeeBasis Bot fee basis.
     */
    function setFeeInfo(
        address _vaultAddress,
        address _charityAddress,
        address _devAddress,
        address _botAddress,
        uint256 _vaultFeeBasis,
        uint256 _charityFeeBasis,
        uint256 _devFeeBasis,
        uint256 _botFeeBasis
    ) external onlyRole(DEV_ROLE) {
        require(
            _vaultAddress != address(0) &&
                _charityAddress != address(0) &&
                _devAddress != address(0) &&
                _botAddress != address(0),
            "Cannot use zero address for fees"
        );
        require(
            _vaultFeeBasis <= 1000 &&
                _charityFeeBasis <= 50 &&
                _devFeeBasis <= 50 &&
                _botFeeBasis <= 10000,
            "Fee constraints"
        );

        vaultAddress = _vaultAddress;
        charityAddress = _charityAddress;
        devAddress = _devAddress;
        botAddress = _botAddress;

        vaultFeeBasis = _vaultFeeBasis;
        charityFeeBasis = _charityFeeBasis;
        devFeeBasis = _devFeeBasis;
        botFeeBasis = _botFeeBasis;
    }

    /**
     * @notice Set address of Rune.
     * @dev The address by default is the mainnet address, use this to change if testing or deploying to testnet. Cannot be called on mainnet.
     * @param _rune Address of Rune.
     */
    function setRune(IERC20 _rune) external onlyRole(DEV_ROLE) {
        require(block.chainid != 56);

        rune = _rune;
    }

    /* SECTION: Hooks. */

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal override {
        super._beforeTokenTransfer(from, to, amount);
    }


    /* SECTION: Overrides. */

    /**
     * @notice Override required by Solidity. No additional functionality.
     *
     * @dev Hook that is called after any transfer of tokens. This includes
     * minting and burning.
     */
    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal override(ERC20, ERC20Votes) {
        super._afterTokenTransfer(from, to, amount);
    }

    /**
     * @notice Override required by Solidity. No additional functionality.
     */
    function _burn(address account, uint256 amount)
        internal
        override(ERC20, ERC20Votes)
    {
        // Cannot burn
    }

    /**
     * @notice Override required by Solidity. No additional functionality.
     */
    function _mint(address to, uint256 amount)
        internal
        override(ERC20, ERC20Votes)
    {
        // Cannot mint
    }

    /**
     * @notice Moves `amount` of tokens from `sender` to `recipient`,
     * applying transfer and bot fees as appropriate.
     */
    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal override {
        uint256 remainingAmount = amount;

        if (!excluded.contains(sender) && !excluded.contains(recipient)) {
            if (vaultFeeBasis > 0) {
                uint256 vaultFee = amount * vaultFeeBasis / BASIS;
                remainingAmount -= vaultFee;
                super._transfer(sender, vaultAddress, vaultFee);
            }
            if (charityFeeBasis > 0) {
                uint256 charityFee = amount * charityFeeBasis / BASIS;
                remainingAmount -= charityFee;
                super._transfer(sender, charityAddress, charityFee);
            }
            if (devFeeBasis > 0) {
                uint256 devFee = amount * devFeeBasis / BASIS;
                remainingAmount -= devFee;
                super._transfer(sender, devAddress, devFee);
            }
        }

        if (bot.contains(sender) || bot.contains(recipient)) {
            if (botFeeBasis > 0) {
                uint256 botFee = remainingAmount * botFeeBasis / BASIS;
                remainingAmount -= botFee;
                super._transfer(sender, botAddress, botFee);
            }
        }

        if (
            balanceOf(sender) - remainingAmount == 0 &&
            remainingAmount > 0 &&
            sender != address(this)
        ) {
            --remainingAmount;
        }

        super._transfer(sender, recipient, remainingAmount);
    }
}
